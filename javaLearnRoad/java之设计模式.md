# 设计模式

## 概括
---

    在平时代码中不用设计模式也不是不可以，但是使用了设计模式能帮助我们更好的解决实际问题，设计模式最重要的是解耦。使用设计模式可以写出 更优雅的代码、更好的重构项目、经典的框架中都在使用设计模式解决问题。

## 我们先来了解下软件架构设计七大原则
---

1. 开闭原则 : 指一个软件如类、模块、和函数应该对扩展开放，对修改关闭。所谓开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节，提高系统的可维护性和可复用性。也是面向对象设计中的最基础的原则
    (对扩展开放，对修改关闭)


2. 依赖倒置原则 : 在代码设计结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应依赖细节，细节应该依赖抽象。通过DIP可以减少类与类之间的耦合，提高系统的稳定性，提高代码的可读性和可维护性。
    (通过抽象使各个类或者模块互不影响，实现松耦合)

3. 单一职责原则 : 指不要存在多余一个导致类变更的原因，就是我们修改一个class的逻辑代码，不会对别的class的class职责功能发生故障，我们需要进行解耦，后续变更维护互不影响。这样设计可以降低类的复杂度，提高类的可读性，提高系统可维护性，降低变更引起的风险。
    (一个类，接口，方法只做一件事)

4. 接口隔离原则 ：指多个专门的接口，而不使用单一的总接口，客户端不应依赖它不需要的接口，应该注意，一个类对一个类的依赖应该建立在最小接口上，建立单一接口，不要建立臃肿庞大的接口，接口中的方法尽量少，这样设计具有很好的可读性，可扩展性和可维护性。
    (尽量保证接口的纯洁性，客户端不应依赖它不需要的接口。)

5. 迪米特法则 ：最少知道原则，指一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合。出现在成员变量、方法的输入、输出中的参数的类都可以称之为成员朋友类。
    (又叫最少知道原则，一个类对其所依赖的类知道的越少越好。)

6. 里氏替换原则 ：子类可以扩展父类的功能，但不能改变父类原有的功能。1）子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 2）子类可以增加自己特有的方法。3）当子类的方法重载父类的方法时，方法的前置条件（即方法的入参）要比父类的方法的输入参数更宽松。4）当子类实现父类的方法时（重写|重载或实现抽象方法时），方法的后置条件（即方法的输出|返回值）要比父类更严格或者相等。
    (子类可以扩展父类的功能，但是不能改变父类原有的功能。)

7. 合成复用原则 ：尽量使用对象组和\聚合，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。
    （尽量使用对象组合、聚合，而不使用继承关系达到复用目的）

# 许多经典的框架中都适用了设计模式来解决问题，例如Spring

    工厂模式    BeanFactory
    装饰器模式  BeanWrapper 
    代理模式    AopProxy 
    委派模式    DispatcherServlet 
    策略模式    HandlerMapping 
    适配器模式  HandlerAdapter 
    模板模式    JdbcTemplate 
    观察者模式  ContextLoaderListener

# 工厂模式

## 1. 简单工厂模式 ：指由一个工厂对象决定创建出哪一种产品类的实例。

    适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑并不关心。
    
    我们写几个例子
```java
        // 简单工厂类
        //1. 正常调用类
        ICourse javaCourse = new JavaCourse();
        javaCourse.record();

        // 2. 添加了 courseFactory 工厂类  ，根据传入的参数，来判断返回那种课程实例
        CourseFactory courseFactory = new CourseFactory();
        courseFactory.create("java");

        // 3. 我们如果新增了 新的课程 还需要去courseFactory 添加逻辑代码。不符合代码的开闭原则
        // 这里我们可以使用反射技术
        CourseFactory courseFactory = new CourseFactory();
        ICourse iCourse = courseFactory.create("com.bootdo.gper.pattern.factory.SimpleFactory.JavaCourse");
        iCourse.record();

        //4. 使用了 反射就不需要再修改courseFactory中的逻辑代码，但是传参是字符串，可控性有待提高，而且还需要强转
        CourseFactory factory = new CourseFactory();
        ICourse course = factory.create(JavaCourse.class);
        course.record();

```
    在JDK中，Calendar 类，看 Calendar.getInstance()方法。经常使用的 logback，我们可以看到 LoggerFactory 中有多个重载的方法getLogger()
    
    简单工厂的缺点：工厂类的职责相对过重，不易于扩展过于复杂的产品结构。

## 2. 工厂方法模式 ：指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

    只需要关心所需的产品对应的工厂，无需关心创建细节，而且加入新的产品符合开闭原则；
    
    工厂方法模式主要解决产品扩展问题，根据单一职责原则，我们将继续拆分，专人干专事。


​    
```java
    // 我们给课程创建接口，课程工厂接口，在分别创建课程的子工厂类
    // 创建统一的 ICourseFactory 课程工厂， 在分别创建 java python 工厂类实现课程工厂，
    // 如果需要新增html课程，则新增一个HTML工厂即可
        ICourseFactory factory = new PythonCourseFactory();
        ICourse course = factory.create();
        course.record();

        factory = new JavaCourseFactory();
        course = factory.create();
        course.record();

```

    工厂模式适用于：
        1. 创建对象需要大量的重复代码
        2. 客户端（产品类）不依赖产品类实例如何被创建，实现等细节
        3. 一个类通过其子类来指定创建那个对象
    
    缺点：
        1. 类的个数容易增多，复杂度增加
        2. 增加了系统的抽象性和理解难度

## 3. 抽象工厂模式：指提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类

    1. 例如我们有视频video、笔记note产品，我们需要实现方法
    2. 创建统一的工厂实现类，来实现对应的产品方法。
    3. 我们还需要创建对应的产品工厂类，去实现统一的工厂类。
    
    使用抽象工厂能够完美的清晰的描述这样的一层复杂关系，但是如果我们再进行对产品的等级进行扩展，那我们需要重抽象工厂到具体工厂全部调整。这样不符合开闭原则。
    
    缺点：
        1. 规定了所有可能被创建的产品集合，产品组扩展新的产品有困难，需要改写抽象类的工厂接口
        2. 增加了系统的抽象性和复杂性



## 









